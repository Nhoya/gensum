#!/bin/bash
#
#		Copyright (C) 2015 sten_gun, Nhoya.
#
#   gensum is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>
dep=(unar wget)
SAVEIFS=$IFS
IFS=$(echo -en "\n\b")
TMPDIR=/tmp/gensum
version="1.7b"
date="(19/02/2016)"
OUTFILE=""
# For text colour
readonly RED="\033[01;31m"
readonly GREEN="\033[01;32m"
readonly BLUE="\033[01;34m"
readonly YELLOW="\033[00;33m"
readonly BOLD="\033[01m"
readonly FINE="\033[0m"

# If the appropriate variables are set, this function writes output to file
# adopting a simpler format like:
#         filename   hash
_writetofile() {
    if [ -n "$OUTFILE" ]; then
        echo -e "$1" >> "$OUTFILE"
    fi
}
# Custom echo function that handles printing on screen.
_echo() {
    if [ -n "$OUTFILE" ]; then
        #echo -en "$2" | sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g" >> "$OUTFILE"
        #if [ ! "$1" == "raw" ]; then
        #    echo -en "\n" >> "$OUTFILE"
        #fi
        return
    fi
    case $1 in
        "raw")
            printf %b "$2"
            return
        ;;
        "info")
            printf %b "$GREEN$2$FINE"
        ;;
        "warn")
            printf %b "$YELLOW$2$FINE"
        ;;
        "error")
            printf %b "$RED$2$FINE"
        ;;
        *)
        ;;
    esac
    printf %b "\n"
}

check_dep(){
if ( which "$1" &>/dev/null ); then
    if [ -n "$DB" ]; then
        _echo "info" "$1 found"
    fi
else
    _echo "error" "$1 not found"
    missing="1"
fi
}


#Prints a spacer. If an argument is provided, it will be printed as the
# spacer "title", like "==> TITLE <=="
spacer() {
    if [ "$#" == "0" ]; then
        _echo "info" "=========================================================="
    fi
    if [ "$#" -gt "0" ]; then
        strn="$1"
        for st in "${@:2:$#}"; do
        strn="$strn $st"
        done
        if [ -z $OUTFILE ]; then
            _echo "warn" "=========================================================="
            tput cuu 1
        fi
        _echo "warn" "==> $FINE$BOLD$strn $FINE$YELLOW<=="
    fi
}

#Generates a checksum for a file or a string. You can specify the program as first argument.
#Second argument is the file/ string of which we want to generate the digest
#the third argument is the index of the entry.
#If necessary compares the generated checksum with a list of checksums given as file.
comparesum() {
    local pre="$BLUE$3) $FINE$BOLD${1/sum/}: $FINE"
    case "$1" in
        "cksum") local parms='{print$1,$2}'
        ;;
        *)
        local parms='{print$1}'
        ;;
    esac
    if ! test -v STR; then
        local csum
        csum=$("$1" "$(basename $2)") 
        _writetofile "$csum"
        csum=$(echo -n $csum | awk $parms)
    else
        local csum
        csum=$(echo -n "$2" | "$1" | awk $parms) # hashing the string
    fi
    if test -v CHKSUMS; then
        (grep "$csum" "$CHKSUMS") > /dev/null
        if [ "$?" == "0" ]; then
            csum="$GREEN$csum OK!$FINE"
        else
            csum="$RED$csum WRONG!$FINE"
        fi
    else
        csum=$BOLD$csum$FINE
    fi
    _echo "raw" "$pre$csum\n"
}

#Calculates checksum for given argument. The argument must be a file.
checksum() {
    spacer "$1"
    local r=1
    if test -v MD5 ; then
        comparesum md5sum "$1" "$r"
        r=$((r+1))
    fi
    if test -v SHA ; then
        if [ "$SHA" == "basic" ] || [ "$SHA" == "1" ] || [ "$SHA" == "all" ]; then
            comparesum sha1sum "$1" "$r"
            r=$((r+1))
        fi
        if [ "$SHA" == "all" ] || [ "$SHA" == "224" ]; then
            comparesum sha224sum "$1" "$r"
            r=$((r+1))
        fi
        if [ "$SHA" == "basic" ] || [ "$SHA" == "256" ] || [ "$SHA" == "all" ] ; then
            comparesum sha256sum "$1" "$r"
            r=$((r+1))
        fi
        if  [ "$SHA" == "all" ] || [ "$SHA" == "384" ]; then
            comparesum sha384sum "$1" "$r"
            r=$((r+1))
        fi
        if [ "$SHA" == "all" ] || [ "$SHA" == "512" ]; then
            comparesum sha512sum "$1" "$r"
            r=$((r+1))
        fi
    fi

    if test -v CK ; then
        comparesum cksum "$1" "$r"
        r=$((r+1))
    fi
    spacer
}

#Asks user if he wants to delete temporary files generated by this script.
ask_del() {
    printf %b "${BOLD}Delete extracted files? ($TMPDIR) [Y/n]$FINE\n"
    read -r input
    case $input in
        ""| [Yy]) rm -rf "$TMPDIR"
            _echo "info" "Files deleted"
        ;;
        *) _echo "warn" "Warning: temporary files saved in $TMPDIR"
        ;;
    esac
}

#Custom exit function, it integrates ask_del for managing script created
#files and folders.
_exit() {
    IFS=$SAVEIFS
    if [[ -d $TMPDIR ]]; then
        ask_del 2>/dev/null
    fi
    exit "$1"
}

#Checks if the file given as argument is an elegible archive.
is_archive() {
    (file "$1" | grep 'compressed\|archive') > /dev/null
    return $?
}

#Recursive function for calculating checksums. It starts checking for archives
#then for directories and then if the argument is a simple file it will
#calculate its checksum.
checksum_cascade() {
    if 	is_archive "$1"; then
        archive "$1"
    elif [[ -d $1 ]]; then
        for file in $1/*; do
            checksum_cascade "$file"
        done
    else
        checksum "$1"
    fi
}

#Extracts the archive given as argument and calls the recursive checksum
#function on its contents.
archive() {
    if is_archive "$1"
    then
        if ! [[ -d $TMPDIR ]] ; then
            mkdir "$TMPDIR"
        fi
        FPATH=$(unar -q -r -o "$TMPDIR" "$1" | grep 'extracted\ to' | awk -F \" '{print$2}')
        checksum "$1" 2>/dev/null
        checksum_cascade "$FPATH"
    else
        _echo "error" "$1 is not an archive."
        spacer
    fi
}

#Usage screen.
help() {
    echo -e "gensum $YELLOW$BOLD$version$FINE $YELLOW$BOLD$date$FINE, powerful multi file, multi checksum generator."
    echo "Copyright(C) 2015 sten_gun, Nhoya"
    echo ""
    echo -e "$BOLD  Usage: $0 [OPTIONS] [ARGS ... ]$FINE"
    echo ""
    echo -e "${GREEN}======================================================================================$FINE"
    echo "  Available Options:"
    echo "    -m              		        Uses MD5 checksum."
    echo "    -s [1| 224| 256| 384| 512 |all]	Uses SHA1|SHA224|SHA256|SHA384|SHA512 or all."
    echo "    -c <file>                         	Specifies a file for checksum check."
    echo "    -k                        		Uses CRC checksum."
    echo "    -d <directory>            		Calculate checksum for files inside a directory."
    echo "    -z <archive>              		Calculate checksum for an archive and its contents."
    echo "    -t <string>                	 	Calculate checksum for strings instead of files."
    echo "    -o <outfile>                          Writes output to outfile."
    echo "    -b                                    Check dependencies."
    echo "    -v                        		Display script version."
    echo "    -h                        		Display this page."
    echo -e "$GREEN======================================================================================$FINE"
}

#==== Main logic functions ====
#Argument parser.
argsparser() {
    urlregex='(https?|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'
    #p=0 #counter of checksum_cascade.
    if [ "$#" == "0" ]
        then help
    fi
    while getopts ":z:d:s:o:mhbvtkc:" opt; do
        case "$opt" in
            h)  help
                _exit 0
            ;;
            b) DB=1
                for i in "${dep[@]}"
                do
                    check_dep "$i"
                done
                _exit 0
            ;;
            o)
                if [[ -e $OPTARG ]]; then
                    _echo "error" "File exists"
                    _echo "raw" "${BOLD}Do you want to append the output on ${OPTARG}? [y/N]$FINE\n"
                    read -r input
                    case $input in
                        "" | [Nn])
                            printf %b "${RED}Output to file disabled$FINE\n"
                        ;;
                        [Yy])
                            printf %b "${YELLOW}Appending output to $OPTARG$FINE\n"
                            OUTFILE=$OPTARG
                        ;;
                        *)
                        ;;
                    esac
                else
                    OUTFILE=$OPTARG
                    touch "$OPTARG"
                fi
            ;;
            c)
                if [[ $OPTARG =~ $urlregex ]]; then
                    if ! [ -d $TMPDIR ]; then
                        mkdir $TMPDIR
                    fi
                    wget "$OPTARG" -O "$TMPDIR/${OPTARG##*/}" -q --show-progress
                    tput cuu 1
                    tput el
                    OPTARG=$TMPDIR/${OPTARG##*/}
                fi
                (file "$OPTARG" | grep "ASCII\ text") > /dev/null
                if [ "$?" == "0" ]; then
                    CHKSUMS=$OPTARG
                else
                    _echo "error" "-x$opt: $OPTARG is not a text file."
                    _exit 0
                fi
            ;;
            s)
                case "$OPTARG" in
                1|224|256|384|512|"all")
                    SHA="$OPTARG"
                ;;
                *)
                    _echo "error" "-s argument is wrong! accepted args: [1| 224| 256| 384| 512 |all]"
                    _exit 1
                ;;
                esac
            ;;
            m) MD5=1
            unset STR
            ;;
            k) CK=1
            ;;
            t) 
                for str in "${@:$OPTIND}"; do
                    STR="$STR $str"
                done
                if [ -v STR ]; then
                    _echo "raw" "${BOLD}String Checksum$FINE\n"
                    spacer
                    STR=$(echo -e "$STR" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
                else
                    _echo "error" "Error: empty string"
                    _exit 1
                fi
                break
            ;;
            :) _echo "error" "-$OPTARG parameter is mandatory."
                _exit 1
            ;;
            v) _echo "raw" "$version $date"
                _exit 0
            ;;
        esac
    done

    if ! [ -v SHA ] && ! [ -v MD5 ]  && ! [ -v CK ]; then
        SHA="basic"
        MD5=1
        CK=1
    fi
    if [ -n "$STR" ]; then
        return
    fi
    OPTIND=1
    while getopts "z:d:s:o:mhbvtkc:" opt; do
        case "$opt" in
          z) if is_archive "$OPTARG"; then
                _echo "raw" "${BOLD}Checking archive $OPTARG$FINE\n"
                p=${p:=1}
                spacer
                checksum_cascade "$OPTARG"
            else
                _echo "error" "-z: $OPTARG is not an archive file."
                _exit 1
            fi
          ;;
          d) if [[ -d $OPTARG ]]; then
                _echo "raw" "${BOLD}Checking directory $OPTARG$FINE\n"
                p=${p:=1}
                spacer
                checksum_cascade "$OPTARG"
            else
                _echo "error" "-d: $OPTARG is not a directory."
                _exit 1
            fi
          ;;
          \?) _echo "error" "invalid option(s): -$OPTARG"
              _exit 1
          ;;
          :) _echo "error" "-$OPTARG needs argument(s)"
             _exit 1
          ;;
        esac
done
}

#Main logic
main(){
    if test -v STR; then
        checksum "$STR"
        _exit 0
    else
        r=0
        for file in "${@:$OPTIND}"; do
            if [ $r == 0 ] ; then
                _echo "raw" "${BOLD}Checking given files$FINE\n"
                spacer
                r=$((r+1))
            fi
            if [ -d "$file" ]; then
                _echo "error" "$file is a directory, skipping."
                spacer
            elif [ -e "$file" ]; then
                    checksum "$file"
            else
                _echo "error" "$file: file  doesn't exists"
                spacer
            fi
        done
    fi
    if [ "$r" == "0" ] && [ "${p:-0}" == "0" ]; then
        _echo "error" "Error: missing arguments."
        _exit 1
    fi
}
#---------------------------------------------------- Script Start
for i in "${dep[@]}"
do
    check_dep "$i"
done

if [ "$missing" == "1" ]; then
    _exit 1
fi
argsparser "$@"
main "$@"
_exit 0
